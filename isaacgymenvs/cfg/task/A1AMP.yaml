# used to create the object
name: A1Dribbling

physics_engine: ${..physics_engine}

rl_device: ${..rl_device}

# if given, will override the device setting in gym.
env:
  priv_obs: false
  historySteps: 15
  numEnvs: ${resolve_default:4096,${...num_envs}}
  envSpacing: 3
  episodeLength: 2000
  cameraFollow: True # if the camera follows humanoid or not
  enableDebugVis: False
  
  pdControl: True
  powerScale: 1.0
  controlFrequencyInv: 30 # 33 Hz
  stateInit: "Hybrid"  # Random
  hybridInitProb: 0.5
  numAMPObsSteps: 5

  localRootObs: True
  contactBodies: ["FR_foot", "FL_foot", "RR_foot", "RL_foot", "FR_calf", "FL_calf", "RR_calf", "RL_calf"]
  terminationHeight: 0.15
  enableEarlyTermination: True

  # animation files to learn from
  motion_file: "dataset.yaml"
#  motion_file: "a1_ig_ofstv1_pace.json"
#  motion_file: "a1_ig_ofstv1_trot2.json"

  asset:
    assetFileName: "urdf/a1_ig.urdf"
    ballAsset: "urdf/soccerball.urdf"
#    assetFileName: "mjcf/a1_test.xml"

  plane:
    staticFriction: 1.0
    dynamicFriction: 1.0
    restitution: 0.0
    limit_space: false
    width: 6.0
    length: 9.0

control:
  control_type: 'P'
  action_scale: 0.25
  stiffness: {'joint': 80.}  # [N*m/rad]
  damping: {'joint': 1.0}

asset:
  foot_name: "None" # name of the feet bodies, used to index body state and contact force tensors
  penalize_contacts_on: []
  terminate_after_contacts_on: []
  disable_gravity: False
  collapse_fixed_joints: True # merge bodies connected by fixed joints. Specific fixed joints can be kept by adding " <... dont_collapse="true">
  fix_base_link: False # fixe the base of the robot
  default_dof_drive_mode: 3 # see GymDofDriveModeFlags (0 is none, 1 is pos tgt, 2 is vel tgt, 3 effort)
  self_collisions: 0 # 1 to disable, 0 to enable...bitwise filter
  replace_cylinder_with_capsule: True # replace collision cylinders with capsules, leads to faster/more stable simulation
  flip_visual_attachments: True # Some .obj meshes must be flipped from y-up to z-up
  
  density: 0.001
  angular_damping: 0.
  linear_damping: 0.
  max_angular_velocity: 1000.
  max_linear_velocity: 1000.
  armature: 0.
  thickness: 0.01


sim:
  dt: 0.001 # pd controller 1000 hz
  substeps: 2
  up_axis: "z"
  use_gpu_pipeline: ${eq:${...pipeline},"gpu"}
  gravity: [0.0, 0.0, -9.81]
  physx:
    num_threads: ${....num_threads}
    solver_type: ${....solver_type}
    use_gpu: ${contains:"cuda",${....sim_device}} # set to False to run on CPU
    num_position_iterations: 4
    num_velocity_iterations: 0
    contact_offset: 0.01 # 0.02 -> 0.01
    rest_offset: 0.0
    bounce_threshold_velocity: 0.5 # 0.2 -> 0.5
    max_depenetration_velocity: 1.0
    default_buffer_size_multiplier: 5.0
    max_gpu_contact_pairs: 8388608 # 8*1024*1024 --> 46
    num_subscenes: ${....num_subscenes}
    contact_collection: 2 # 0: CC_NEVER (don't collect contact info), 1: CC_LAST_SUBSTEP (collect only contacts on last substep), 2: CC_ALL_SUBSTEPS (default - all contacts)

task:
  randomize: False
  randomization_params:
    # specify which attributes to randomize for each actor type and property
    frequency: 600   # Define how many environment steps between generating new randomizations
    observations:
      range: [0, .002] # range for the white noise
      operation: "additive"
      distribution: "gaussian"
    actions:
      range: [0., .02]
      operation: "additive"
      distribution: "gaussian"
    sim_params: 
      gravity:
        range: [0, 0.4]
        operation: "additive"
        distribution: "gaussian"
        schedule: "linear"  # "linear" will linearly interpolate between no rand and max rand
        schedule_steps: 3000
    actor_params:
      a1:
        color: True
        rigid_body_properties:
          mass: 
            range: [0.5, 1.5]
            operation: "scaling"
            distribution: "uniform"
            setup_only: True # Property will only be randomized once before simulation is started. See Domain Randomization Documentation for more info.
            schedule: "linear"  # "linear" will linearly interpolate between no rand and max rand
            schedule_steps: 3000
        rigid_shape_properties:
          friction:
            num_buckets: 500
            range: [0.7, 1.3]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000
          restitution:
            range: [0., 0.7]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000
        dof_properties:
          damping: 
            range: [0.5, 1.5]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000
          stiffness: 
            range: [0.5, 1.5]
            operation: "scaling"
            distribution: "uniform"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000
          lower:
            range: [0, 0.01]
            operation: "additive"
            distribution: "gaussian"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000
          upper:
            range: [0, 0.01]
            operation: "additive"
            distribution: "gaussian"
            schedule: "linear"  # "linear" will scale the current random sample by `min(current num steps, schedule_steps) / schedule_steps`
            schedule_steps: 3000
          soft_dof_pos_limit: 1
          soft_dof_torque_limit: 1

  domain_rand:
    randomize_friction: False
    friction_range: [0., 0.5]
    randomize_joint_friction: False
    joint_friction_std: 0.01
    randomize_base_mass: False
    mass_ratio_range: 0.75
    inertia_ratio_range: 0.2
    randomize_PD: False
    push_robots: False
    push_interval_s: 0.2
    push_ball: False

  noise:
    add_noise: False
    add_delay: False
    noise_level: 1.0 # scales other values
    delay_bound: [0.0004, 0.025] #40
    add_ball_delay: False
    noise_scales:
      base_quat: 0.01
      dof_pos: 0.01
      dof_vel: 0.05
      ball_pos: 0.01
      gravity: 0.05
      height_measurements: 0.1

  action_filter: True
  reward:
    actor_vel_scale: 1.5
    ball_vel_scale: 2.0
    energy_scale: 0.001
    energy_weight: 0.01
    ab_dist_threshold: 0.5
    piecewise: True
  goal_reset_freq_inv: 4
  goal_reset_freq_inv_upper: 2
  is_additive: True
  randomize_goal: True
  randomize_obj: false
  obj_size_range: [0.08, 0.12]
  obj_density_range: [80, 200]
  ball_size: 0.1

